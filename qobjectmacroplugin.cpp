#include "qobjectmacroplugin.h"


using namespace google::protobuf;
bool QObjectMacroGenerator::Generate( const FileDescriptor *file,
                                      const std::string &parameter,
                                      compiler::GeneratorContext *generator_context,
                                      std::string *error ) const
{
    Q_UNUSED(parameter)
    try
    {
        auto path = compiler::cpp::StripProto( file->name() );
        path.append( ".pb.h" );
        std::unique_ptr<io::ZeroCopyOutputStream> out(
                    generator_context->Open( path ) );
        io::Printer p( out.get(), '$' );
        FileGenerator g( file );
        g.generateObjMacroFile( p );
        return true;
    }
    catch( std::exception &ex )
    {
        *error = ex.what();
        return false;
    }
}

FileGenerator::FileGenerator( const FileDescriptor *file )
    : file_( file )
{
    if( !file )
    {
        throw std::invalid_argument( "File descriptor is null" );
    }


}

void FileGenerator::generateObjMacroFile( io::Printer &p )
{
    for (int i = 0; i < file_->enum_type_count(); i++) {
        qDebug() << "dfjakjldjl" << file_->enum_type( i ) ;
    }


    // fixme Generated String
    p.Print( "/*\n This file was generated by Synexxus Code\n"
             " Generated on $now_time$"
             "\n*/"
             "\n\n",
             "now_time", QDateTime::currentDateTime().toString( Qt::ISODate ).toStdString().c_str()
             );

    //FIXME Get Lic

    // FIXME get default headers
    p.Print( "#include <QObject>\n" );
    p.Print( "#include \"QQmlConstRefPropertyHelpers.h\" \n" );
    p.Print( "#include \"QQmlObjectListModel.h\" \n \n" );
    setPackageName( QString::fromStdString( file_->package().c_str() ));

    for( int i = 0; i < file_->dependency_count(); i++ )
    {
        auto d = file_->dependency( i )->name();
        auto path = compiler::cpp::StripProto( d );
        QString camelPath = QString::fromStdString( path.c_str() );
        QString includePath = camelPath.append(".pb.h").toLower() ;
        p.Print("#include \"");
        p.Print( includePath.toStdString().c_str() );
        p.Print( "\"\n");
    }
    setIfDefName( QString::fromStdString( file_->message_type( 0 )->name().c_str() ) );
    for( int i = 0; i < file_->message_type_count(); i++ )
    {
        generateMessage( p, file_->message_type( i ) );
    }
}

void FileGenerator::generateMessage( io::Printer &p, const Descriptor *t )
{
    if (!t) {
        throw std::invalid_argument("Null descriptor");
    }

    if( !m_writableMacros.isEmpty()  )
    {
        m_writableMacros.clear();
    }
    if( !m_enumMacros.isEmpty() )
    {
        m_enumMacros.clear();
    }


    // loop all the message fields
    for( int i = 0; i < t->enum_type_count() ; i++ )
    {
        QString enum_name = QString::fromStdString( t->enum_type(i)->name().c_str() );
        QStringList enum_values;
        enum_values.clear();

        for( int u = 0; u < t->enum_type(i)->value_count(); u++  )
        {
            enum_values << QString::fromStdString(
                               t->enum_type( i )->value( u )->name()
                               );
        }
        QPair<QString, QStringList > enum_pair;
        enum_pair.first = enum_name;
        enum_pair.second = enum_values;
        m_enumMacros.insert(i , enum_pair );
    }

    for( int i = 0; i < t->field_count(); i++ )
    {
        qDebug() << QString::fromStdString( t->field(i)->full_name().c_str() )  ;
        QString camelName = QString::fromStdString( t->field( i )->camelcase_name() );
        QString qtType = toQtType( t->field( i )->cpp_type() );
        if( qtType != "enum" )
        {
            m_writableMacros.insert( camelName, qtType );
            //            qDebug() << qtType << camelName <<"hash length " << m_writableMacros.size();
        }
    }

    // namespace
    p.Print( "\nnamespace $package_name$ {\n"
             ,"package_name", getPackageName() );


    // out ifdef
    p.Print("\n#ifndef $ifdef_name$"
            "\n#define $ifdef_name$"
            ,"ifdef_name" , getIfDefName() );

    p.Print( "\nclass $message_name$ : public QObject "
                "\n{"
                "\n    Q_OBJECT"
                "\n    Q_CLASSINFO( \"autor\", \"Synexxus\" )"
                "\n    Q_CLASSINFO( \"url\", \"http://synexxus.com/\" )"
                , "message_name", t->name()
                );

    // add the protoced macros
    QHashIterator< QString, QString > iter( m_writableMacros );
    while ( iter.hasNext() )
    {
        iter.next();
        p.Print( "\n    QML_WRITABLE_CSTREF_PROPERTY( $qml_type$ , $qml_access$ )"
                 , "qml_type", iter.value().toStdString().c_str()
                 , "qml_access", iter.key().toStdString().c_str()
                 );
    }


    QHashIterator<int, QPair<QString, QStringList >> enum_iter( m_enumMacros );
    while( enum_iter.hasNext() )
    {
        enum_iter.next();
        QPair<QString , QStringList> enum_pair;
        enum_pair = enum_iter.value();

        p.Print( "\n    Q_PROPERTY( $enum_name$ $enum_topName$ $enum_topName$ READ $enum_topName$ WRITE set$enum_topName$ NOTIFY $enum_topName$Changed)"
                 , "enum_name", enum_pair.first.toStdString().c_str()
                 , "enum_topName", enum_pair.first.toLower().toStdString().c_str()
                 );
        p.Print( "\n    Q_ENUMS( $enum_Name$ )"
                 , "enum_Name", enum_pair.first.toStdString().c_str());

        p.Print( "\npublic:");
        p.Print("\n     enum $enum_name$ "
                "       {"
                , "enum_name", enum_pair.first.toStdString().c_str()
                );
        int tempEnum = 0;
        foreach( QString l, enum_pair.second )
        {
            if( tempEnum == 0 )
            {
                p.Print("\n        $lower_name$ = $i$"
                        ,"lower_name", l.toStdString().c_str()
                        , "i", QString::number( tempEnum ).toStdString().c_str()
                        );

            }
            else
            {
                p.Print("\n        $lower_name$ = $i$ ,"
                        ,"lower_name", l.toStdString().c_str()
                        , "i", QString::number( tempEnum ).toStdString().c_str()
                        );
            }

            tempEnum = tempEnum + 1;

        }
        p.Print("\n    };");

        p.Print( "\n    void set$enum_lower$( const $enum_name$ &$enum_lower$ )"
                 "\n    {"
                 "\n    if( m_$enum_lower$ != $enum_lower$ )"
                 "\n    {"
                 "\n        m_$enum_lower$ = $enum_lower$;"
                 "\n        emit $enum_name$Changed();"
                 "\n    }"
                 "\n"
                 "\n    $enum_name$ $enum_lower$()const"
                 "\n    {"
                 "\n        return m_$enum_lower$;"
                 "\n    }"
                 , "enum_name" , enum_pair.first.toStdString().c_str()
                 , "enum_lower", enum_pair.first.toLower().toStdString().c_str()
                 );
        p.Print("\nprivate: "
                "\n     $enum_name$ m_$enum_lower$"
                ,"enum_name", enum_pair.first.toStdString().c_str()
                ,"enum_lower", enum_pair.first.toLower().toStdString().c_str()
                );
    }






    ////////////////////////////

    p.Print("\npublic: \n"
            "    explicit $message_name$(",
            "message_name", t->name() );

    QHashIterator<QString, QString> inherntHash(m_writableMacros);
    int commaHelper = 0;
    while (inherntHash.hasNext() ) {
        inherntHash.next();
        if( commaHelper == 0 )
        {
            p.Print( "\n        const $qml_type$ &$qml_name$"
                     , "qml_type", inherntHash.value().toStdString().c_str()
                     , "qml_name", inherntHash.key().toStdString().c_str()
                     );
        }
        else
        {
            p.Print( "\n        ,const $qml_type$ &$qml_name$"
                     , "qml_type", inherntHash.value().toStdString().c_str()
                     , "qml_name", inherntHash.key().toStdString().c_str()
                     );
        }
        commaHelper = commaHelper +1;
    }

    p.Print( "\n    ):" );
    QHashIterator<QString, QString> obSetterHash(m_writableMacros);
    int commaHelperSetter = 0;
    while ( obSetterHash.hasNext() ) {
        obSetterHash.next();
        if( commaHelperSetter == 0 )
        {
            p.Print( "\n        m_$qml_type$( &$qml_name$ )"
                     , "qml_type", obSetterHash.value().toStdString().c_str()
                     , "qml_name", obSetterHash.key().toStdString().c_str()
                     );
        }
        else
        {
            p.Print( "\n        ,m_$qml_type$( &$qml_name$ )"
                     , "qml_type", obSetterHash.value().toStdString().c_str()
                     , "qml_name", obSetterHash.key().toStdString().c_str()
                     );
        }
        commaHelperSetter = commaHelper +1;
    }
    // close out the Object class
    p.Print("\n    {}");
    p.Print("\n};");



    p.Print("#endif // $name_cap$"
            , "name_cap", getIfDefName() );


    p.Print( "\n\nclass $model_name$Model : public QQmlObjectListModel<$model_name$> { "
             "\n"
             "\n};"
             , "model_name" , t->name() );



    // end namespace
    p.Print("\n}");

    // EOF
    p.Print("\n\n");
}

QString FileGenerator::toQtType( FieldDescriptor::CppType cppType)
{
    QString qtType;
    if ( cppType == FieldDescriptor::CPPTYPE_INT32){ qtType = "int" ; }
    else if ( cppType == FieldDescriptor::CPPTYPE_INT64){ qtType = "int" ; }
    else if ( cppType == FieldDescriptor::CPPTYPE_UINT32){ qtType = "int" ; }
    else if ( cppType == FieldDescriptor::CPPTYPE_UINT64){ qtType = "int" ; }
    else if ( cppType == FieldDescriptor::CPPTYPE_DOUBLE){ qtType = "double" ; }
    else if ( cppType == FieldDescriptor::CPPTYPE_FLOAT){ qtType = "float" ; }
    else if ( cppType == FieldDescriptor::CPPTYPE_BOOL){ qtType = "bool" ;}
    else if ( cppType == FieldDescriptor::CPPTYPE_STRING){ qtType = "QString" ; }
    else if ( cppType == FieldDescriptor::CPPTYPE_ENUM ){qtType = "enum"; }
    return qtType;
}

std::__cxx11::string FileGenerator::getIfDefName()
{
    return m_ifdefName;
}

void FileGenerator::setPackageName(QString name)
{
    std::string tmpPackageName = name.replace(".",":").toStdString().c_str();
    if( m_packageName != tmpPackageName )
    {
        m_packageName = tmpPackageName;
    }
}

std::__cxx11::string FileGenerator::getPackageName()
{
    return m_packageName;
}

void FileGenerator::setIfDefName( const QString &name )
{
    std::string tmpIfDef = name.toUpper().toStdString().c_str();
    if( m_ifdefName != tmpIfDef )
    {
        m_ifdefName = tmpIfDef;
    }
}

